class Time
  def self.random(params={})
    years_back = params[:year_range] || 5
    year = (rand * (years_back)).ceil + (Time.now.year - years_back)
    month = (rand * 12).ceil
    day = (rand * 31).ceil
    series = [date = Time.local(year, month, day)]
    if params[:series]
      params[:series].each do |some_time_after|
        series << series.last + (rand * some_time_after).ceil
      end
      return series
    end
    date
  end
end 

# A new rake to generate ShapeAnnotations  & Points

namespace :markus do
  namespace :simulator do
    desc "Generate Shapes  & Points"
    task(:shape => :environment) do
        puts "start generating assignment #1"
	assignment_short_identifier = "A1"
        assignment = Assignment.create
        rule = NoLateSubmissionRule.new
        assignment.short_identifier = assignment_short_identifier
        assignment.description = "Conditionals and Loops"
        assignment.message = "Learn to use conditional statements, and loops."  
        assignment_due_date = Time.random(:year_range=>1)
        
        if (!ENV["PASSED_DUE_DATE"].nil? and ENV["PASSED_DUE_DATE"] == "true")
          assignment_due_date = Time.now
       
        elsif (!ENV["PASSED_DUE_DATE"].nil? and ENV["PASSED_DUE_DATE"] == "false")
          assignment_due_date = Time.now + 5184000
        end
        assignment.due_date = assignment_due_date

        assignment.group_min = 1
        assignment.group_max = 1
        assignment.student_form_groups = false
        assignment.group_name_autogenerated = true
        assignment.group_name_displayed = false
        assignment.repository_folder = assignment_short_identifier
        assignment.submission_rule = rule
        assignment.instructor_form_groups = false
        assignment.marking_scheme_type = Assignment::MARKING_SCHEME_TYPE[:rubric]
        assignment.display_grader_names_to_students = false
        assignment.save

	group = Group.create
	group.group_name=rand(10)
	group.save

	grouping = Grouping.create
	grouping.assignment_id=assignment.id
	grouping.group_id=group.id
	grouping.save

	date_of_submission = Time.random(:year_range=>1)
	submission = Submission.create_by_timestamp(grouping, date_of_submission)
	submission.save

	submissionfile=SubmissionFile.create
	submissionfile.submission_id=submission.id
	submissionfile.filename='File'
	submissionfile.save

	annotationtext=AnnotationText.create
	annotationtext.content="Assignment goals pretty much met, but some things would need improvement. Other things are absolutely fantastic! Seriously, this is 		just some random text."
	annotationtext.save

	annotation=ShapeAnnotation.create
	annotation.annotation_text_id=annotationtext.id
	annotation.submission_file_id=submissionfile.id
	annotation.type='ShapeAnnotation'
	annotation.thickness=rand(10)
	annotation.color='#FF0000'
	annotation.annotation_number=rand(10)
	annotation.save

	num_of_shapes = rand(3) + 3
	curr_shape_num=1
	while(curr_shape_num <= num_of_shapes) do
		
	        puts "Start Generating ShapeAnnotation # "+ curr_shape_num.to_s
			shapeAnnotation = ShapeAnnotation.create
			shapeAnnotation.color = '#FF0000'
			shapeAnnotation.annotation_number=annotation.annotation_number
			shapeAnnotation.annotation_text_id=annotationtext.id
			shapeAnnotation.thickness = rand(5)
			shapeAnnotation.submission_file_id=submissionfile.id

			if !shapeAnnotation.save
				puts "shapeAnnotation is not saved"
			end

		puts "Finish Creating ShapeAnnotation # "+ curr_shape_num.to_s

		num_of_points = rand(6) + 10
		curr_point_num = 1
		
		while (curr_point_num <= num_of_points) do
			puts "Start Generating Point # " + curr_point_num.to_s + " of Shape # "+ curr_shape_num.to_s
				point=Point.create
				point.order= curr_point_num
				point.coord_x=point_x=rand(100)
				point.coord_y=point_y=rand(100)
				point.shape_annotation_id=shapeAnnotation.id

				if !point.save
				puts "Point is not saved"
				end

	    			puts "Finish creating Point # " + curr_point_num.to_s + " of Shape # "+ curr_shape_num.to_s
			curr_point_num += 1
          	end
		curr_shape_num += 1
      	end
    end
  end
end

